// Generated by LiveScript 1.2.0
(function(){
  var ref$, id, Obj, map, concat, filter, each, find, fold, foldr, fold1, all, flatten, sum, product, zipAll, groupBy, objToPairs, partition, join, unique, sortBy, reverse, empty, zip, takeWhile, breakList, span, head, last, exports, random, floor, ceil, round, pow, sqrt, pi, exp, abs, sequence, sequenceA, parseNum, shuffle, wait, toss, trial, manyTrials, randomBin, manyRandomBins, boolToHeadtail, isHead, isTail, choose, binomialCoefficient, binomialDistributionFunction, binomialDistribution, binomialDistributionConfidence, binomialDistributionFindConfidenceInterval, binomialDistributionFindConfidenceIntervalOfDistribution, normalDistributionFunction, normalDistribution, binomialNormalApproximation, slice$ = [].slice;
  ref$ = require('prelude-ls'), id = ref$.id, Obj = ref$.Obj, map = ref$.map, concat = ref$.concat, filter = ref$.filter, each = ref$.each, find = ref$.find, fold = ref$.fold, foldr = ref$.foldr, fold1 = ref$.fold1, all = ref$.all, flatten = ref$.flatten, sum = ref$.sum, product = ref$.product, zipAll = ref$.zipAll, groupBy = ref$.groupBy, objToPairs = ref$.objToPairs, partition = ref$.partition, join = ref$.join, unique = ref$.unique, sortBy = ref$.sortBy, reverse = ref$.reverse, empty = ref$.empty, zip = ref$.zip, takeWhile = ref$.takeWhile, breakList = ref$.breakList, span = ref$.span, head = ref$.head, last = ref$.last;
  exports = exports || this;
  random = Math.random;
  floor = Math.floor;
  ceil = Math.ceil;
  round = Math.round;
  pow = Math.pow;
  sqrt = Math.sqrt;
  pi = Math.PI;
  exp = Math.exp;
  abs = Math.abs;
  sequence = curry$(function(fs, v){
    var i$, len$, f, results$ = [];
    for (i$ = 0, len$ = fs.length; i$ < len$; ++i$) {
      f = fs[i$];
      results$.push(f(v));
    }
    return results$;
  });
  sequenceA = curry$(function(list, init, callback){
    var f, fs;
    f = list[0], fs = slice$.call(list, 1);
    switch (false) {
    case !empty(list):
      callback(init);
      break;
    default:
      f(function(d){
        return sequenceA(fs, [d].concat(init), callback);
      });
    }
  });
  parseNum = function(s){
    var n;
    n = +s;
    if (isNaN(n)) {
      return 0;
    } else {
      return n;
    }
  };
  shuffle = function(arr){
    var alength;
    alength = arr.length;
    return map(function(arg$){
      var v, r;
      v = arg$[0], r = arg$[1];
      return v;
    })(
    sortBy(function(arg$){
      var v, r;
      v = arg$[0], r = arg$[1];
      return r;
    })(
    zipAll(arr, map(function(){
      return Math.random();
    }, (function(){
      var i$, to$, results$ = [];
      for (i$ = 0, to$ = alength; i$ <= to$; ++i$) {
        results$.push(i$);
      }
      return results$;
    }())))));
  };
  wait = function(time, f){
    return setTimeout(f, time);
  };
  toss = function(){
    return round(random());
  };
  trial = function(numberOfBins){
    return map(toss, (function(){
      var i$, to$, results$ = [];
      for (i$ = 1, to$ = numberOfBins; i$ <= to$; ++i$) {
        results$.push(i$);
      }
      return results$;
    }()));
  };
  manyTrials = curry$(function(numberOfBins, numberOfTrials){
    return map(function(){
      return trial(numberOfBins);
    }, (function(){
      var i$, to$, results$ = [];
      for (i$ = 1, to$ = numberOfTrials; i$ <= to$; ++i$) {
        results$.push(i$);
      }
      return results$;
    }()));
  });
  randomBin = function(numberOfBins){
    return sum(trial(numberOfBins));
  };
  manyRandomBins = curry$(function(numberOfBins, numberOfTrials){
    return map(sum, manyTrials(numberOfBins, numberOfTrials));
  });
  boolToHeadtail = function(it){
    if (isHead(it)) {
      return 'Head';
    } else {
      return 'Tail';
    }
  };
  isHead = function(i){
    return i === 1;
  };
  isTail = function(i){
    return !isHead(i);
  };
  choose = curry$(function(n, k){
    return function(){
      return product(map(function(it){
        return (n - (k - it)) / it;
      }).apply(this, arguments));
    }((function(){
      var i$, to$, results$ = [];
      for (i$ = 1, to$ = k; i$ <= to$; ++i$) {
        results$.push(i$);
      }
      return results$;
    }()));
  });
  binomialCoefficient = function(n){
    return map(choose(n), (function(){
      var i$, to$, results$ = [];
      for (i$ = 0, to$ = n; i$ <= to$; ++i$) {
        results$.push(i$);
      }
      return results$;
    }()));
  };
  binomialDistributionFunction = curry$(function(n, p, k){
    return choose(n, k) * pow(p, k) * pow(1 - p, n - k);
  });
  binomialDistribution = function(n, p){
    return map(binomialDistributionFunction(n, p), (function(){
      var i$, to$, results$ = [];
      for (i$ = 0, to$ = n; i$ <= to$; ++i$) {
        results$.push(i$);
      }
      return results$;
    }()));
  };
  binomialDistributionConfidence = curry$(function(n, p, left, right){
    return function(){
      return sum(map(function(it){
        return it.y;
      }).apply(this, arguments));
    }(
    filter(function(arg$){
      var x, y;
      x = arg$.x, y = arg$.y;
      return left <= x && x <= right;
    })(
    map(function(arg$){
      var i, v;
      i = arg$[0], v = arg$[1];
      return {
        x: i,
        y: v
      };
    })(
    zip((function(){
      var i$, to$, results$ = [];
      for (i$ = 0, to$ = n; i$ <= to$; ++i$) {
        results$.push(i$);
      }
      return results$;
    }()))(
    binomialDistribution(n, p)))));
  });
  binomialDistributionFindConfidenceInterval = curry$(function(n, p, confidence){
    var distribution;
    distribution = map(function(arg$){
      var i, v;
      i = arg$[0], v = arg$[1];
      return {
        x: i,
        y: v
      };
    })(
    zip((function(){
      var i$, to$, results$ = [];
      for (i$ = 0, to$ = n; i$ <= to$; ++i$) {
        results$.push(i$);
      }
      return results$;
    }()))(
    binomialDistribution(n, p)));
    return binomialDistributionFindConfidenceIntervalOfDistribution(distribution, confidence);
  });
  binomialDistributionFindConfidenceIntervalOfDistribution = curry$(function(distribution, confidence){
    var confidenceSum, mu, rmu;
    if (confidence === 1) {
      return {
        left: head(distribution).x,
        right: last(distribution).x,
        c: 1
      };
    }
    confidenceSum = function(left, right){
      return function(){
        return sum(map(function(it){
          return it.y;
        }).apply(this, arguments));
      }(
      filter(function(arg$){
        var x, y;
        x = arg$.x, y = arg$.y;
        return left <= x && x <= right;
      })(
      distribution));
    };
    mu = function(){
      return sum(map(function(arg$){
        var x, y;
        x = arg$.x, y = arg$.y;
        return x * y;
      }).apply(this, arguments));
    }(
    distribution);
    rmu = round(
    mu);
    return head(
    map(function(arg$){
      var v, d;
      v = arg$.v, d = arg$.d;
      return v;
    })(
    sortBy(function(arg$){
      var v, d;
      v = arg$.v, d = arg$.d;
      return d;
    })(
    map(function(it){
      return {
        v: it,
        d: abs(confidence - it.c)
      };
    })(
    filter(function(it){
      return !!it;
    })(
    function(arg$){
      var a, b;
      a = arg$[0], b = arg$[1];
      return [last(a), head(b)];
    }(
    span(function(arg$){
      var _, c;
      _ = arg$._, _ = arg$._, c = arg$.c;
      return c <= confidence;
    })(
    map(function(arg$){
      var left, right;
      left = arg$[0], right = arg$[1];
      return {
        left: left,
        right: right,
        c: confidenceSum(left, right)
      };
    })(
    map(function(it){
      return [rmu - it, rmu + it];
    }, (function(){
      var i$, to$, results$ = [];
      for (i$ = 0, to$ = rmu; i$ <= to$; ++i$) {
        results$.push(i$);
      }
      return results$;
    }()))))))))));
  });
  normalDistributionFunction = curry$(function(mu, sigma, x){
    return exp((x - mu) * (x - mu) / (-2 * sigma * sigma)) / (sigma * sqrt(2 * pi));
  });
  normalDistribution = function(mu, sigma){
    return map(normalDistributionFunction(mu, sigma), (function(){
      var i$, to$, results$ = [];
      for (i$ = 0, to$ = mu * 2; i$ <= to$; ++i$) {
        results$.push(i$);
      }
      return results$;
    }()));
  };
  binomialNormalApproximation = curry$(function(n, p){
    return normalDistribution(n * p, sqrt(n * p * (1 - p)));
  });
  exports.abs = abs;
  exports.random = random;
  exports.floor = floor;
  exports.ceil = ceil;
  exports.round = round;
  exports.pow = pow;
  exports.sequence = sequence;
  exports.sequenceA = sequenceA;
  exports.parseNum = parseNum;
  exports.shuffle = shuffle;
  exports.wait = wait;
  exports.noop = $.noop;
  exports.toss = toss;
  exports.trial = trial;
  exports.manyTrials = manyTrials;
  exports.randomBin = randomBin;
  exports.manyRandomBins = manyRandomBins;
  exports.boolToHeadtail = boolToHeadtail;
  exports.isHead = isHead;
  exports.isTail = isTail;
  exports.choose = choose;
  exports.binomialCoefficient = binomialCoefficient;
  exports.binomialDistributionFunction = binomialDistributionFunction;
  exports.binomialDistribution = binomialDistribution;
  exports.binomialDistributionConfidence = binomialDistributionConfidence;
  exports.binomialDistributionFindConfidenceInterval = binomialDistributionFindConfidenceInterval;
  exports.binomialDistributionFindConfidenceIntervalOfDistribution = binomialDistributionFindConfidenceIntervalOfDistribution;
  exports.normalDistribution = normalDistribution;
  exports.binomialNormalApproximation = binomialNormalApproximation;
  function curry$(f, bound){
    var context,
    _curry = function(args) {
      return f.length > 1 ? function(){
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
}).call(this);
